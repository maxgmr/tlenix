//! Thread control.

use core::time::Duration;

use crate::{Errno, SyscallNum, syscall_result};

/// Intel 8253/8254 sends an IRQ0 (timer interrupt) once every ~52.9254 ms.
///
/// This is used for sleep loop timing.
pub const PIT_IRQ_PERIOD: u64 = 54_925_400;

/// Corresponds to the [timespec](https://www.man7.org/linux/man-pages/man3/timespec.3type.html)
/// type in C.
#[derive(Debug, Default)]
#[repr(C)]
struct Timespec {
    /// Seconds.
    sec: i64,
    /// Nanoseconds.
    nsec: i64,
}
impl From<&Duration> for Timespec {
    fn from(value: &Duration) -> Self {
        Self {
            #[allow(clippy::cast_possible_wrap)]
            sec: value.as_secs() as i64,
            nsec: i64::from(value.subsec_nanos()),
        }
    }
}

/// Endlessly loops, sleeping the thread.
///
/// # Errors
///
/// This function returns an error if [`sleep`] returns an error.
pub fn sleep_loop() -> Result<!, Errno> {
    let sleep_duration = core::time::Duration::from_nanos(PIT_IRQ_PERIOD);
    loop {
        sleep(&sleep_duration)?;
    }
}

/// Guaranteed endless loop. Sleeps the thread unless an error is encountered.
///
/// This function differs from [`sleep_loop`] through its guarantee- it will never return, no
/// matter what, but if [`sleep`] returns an error for whatever reason, an empty loop will be used
/// as a fallback, wasting CPU cycles.
pub fn sleep_loop_forever() -> ! {
    let _ = sleep_loop();
    // Fallback loop if sleep_loop breaks :(
    #[allow(clippy::empty_loop)]
    loop {}
}

/// Suspends the execution of the calling thread until at least the given [`Duration`] has elapsed.
///
/// # Panics
///
/// This function panics if the number of _whole_ seconds contained by the [`Duration`] is too
/// large to fit inside a [`core::i64`].
///
/// # Errors
///
/// This function can return any errors generated by the [nanosleep](https://man7.org/linux/man-pages/man2/nanosleep.2.html)
/// Linux syscall.
pub fn sleep(duration: &Duration) -> Result<(), Errno> {
    let mut duration_timespec = Timespec::from(duration);
    let mut remaining_duration = Timespec { sec: 0, nsec: 0 };
    loop {
        // SAFETY: The pointers and arguments are valid. UB can occur if pointers are misaligned.
        match unsafe {
            syscall_result!(
                SyscallNum::Nanosleep,
                &raw const duration_timespec as usize,
                &raw mut remaining_duration as usize
            )
        } {
            Ok(_) => return Ok(()),
            Err(Errno::Eintr) => {
                // Sleep was interrupted!

                // Exit early if no time left.
                if remaining_duration.sec == 0 && remaining_duration.nsec == 0 {
                    return Ok(());
                }
                // `remaining_duration` now contains the remaining time. Move that to
                // `duration_timespec` and continue looping.
                duration_timespec.sec = remaining_duration.sec;
                duration_timespec.nsec = remaining_duration.nsec;
            }
            Err(e) => return Err(e),
        }
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
mod tests {
    use super::*;

    #[test_case]
    fn secs() {
        sleep(&Duration::from_secs(2)).unwrap();
    }

    #[test_case]
    fn nsecs() {
        sleep(&Duration::from_nanos(500_000)).unwrap();
    }
}
